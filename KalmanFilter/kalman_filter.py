import numpy as np
import matplotlib.pyplot as plt
from scipy.linalg import inv

class KalmanFilter(object):
    def __init__(self,F,Q,H,R,u):
        """
        Initialize the dynamical system models.

        Parameters
        ----------
        F : ndarray of shape (n,n)
            The state transition model.
        Q : ndarray of shape (n,n)
            The covariance matrix for the state noise.
        H : ndarray of shape (m,n)
            The observation model.
        R : ndarray of shape (m,m)
            The covariance matric for observation noise.
        u : ndarray of shape (n,)
            The control vector.
        """
        # store values in way that denotes variable is class member ############
        self.F_ = F
        self.Q_ = Q
        self.H_ = H
        self.R_ = R
        self.u_ = u


    def evolve(self,x0,N):
        """
        Compute the first N states and observations generated by the Kalman system.

        Parameters
        ----------
        x0 : ndarray of shape (n,)
            The initial state.
        N : integer
            The number of time steps to evolve.

        Returns
        -------
        states : ndarray of shape (n,N)
            The i-th column gives the i-th state.
        obs : ndarray of shape (m,N)
            The i-th column gives the i-th observation.
        """
        # initialize necessary values ##########################################
        n = len(self.F_)
        m = len(self.H_)
        states = np.zeros((n, N))
        obs = np.zeros((m, N))

        # calculate N states and observations ##################################
        states[:, 0] = x0
        for i in range(N):
            x_k = states[:, i]
            obs[:, i] = self.H_@x_k +\
                np.random.multivariate_normal(np.zeros(m), self.R_)

            if i != (N - 1):
                states[:, i + 1] = self.F_@x_k + self.u_ +\
                    np.random.multivariate_normal(np.zeros(n),self.Q_)

        return states, obs


    def estimate(self,x0,P0,z):
        """
        Compute the state estimates using the kalman filter.

        Parameters
        ----------
        x0 : ndarray of shape (n,)
            The initial state estimate.
        P0 : ndarray of shape (n,n)
            The initial error covariance matrix.
        z : ndarray of shape(m,N)
            Sequence of N observations (each column is an observation).

        Returns
        -------
        out : ndarray of shape (n,N)
            Sequence of state estimates (each column is an estimate).
        """
        # initialize necessary values ##########################################
        n = len(x0)
        N = z.shape[1]
        out = np.zeros((n, N))
        out[:, 0] = x0

        # compute estimates for the states and perform necessary updates #######
        for i in range(1, N):
            x_k = self.F_@out[:, i - 1] + self.u_
            P_k = self.F_@P0@self.F_.T + self.Q_
            y_k = z[:, i - 1] - self.H_@x_k
            S_k = self.H_@P_k@self.H_.T + self.R_
            K_k = P_k@self.H_.T@inv(S_k)
            out[:,i] = x_k + K_k@y_k
            P0 = (np.eye(n) - K_k@self.H_)@P_k

        return out[:, 1:]


    def predict(self,x,k):
        """
        Predict the next k states in the absence of observations.

        Parameters
        ----------
        x : ndarray of shape (n,)
            The current state estimate.
        k : integer
            The number of states to predict.

        Returns
        -------
        out : ndarray of shape (n,k)
            The next k predicted states.
        """
        # initialize necessary values ##########################################
        n = len(x)
        out = np.zeros((n, k))
        out[:, 0] = x

        # predict next k states ################################################
        for i in range(1, k):
            out[:, i] = self.F_@out[:, i - 1] + self.u_

        return out[:, 1:]


    def rewind(self,x,k):
        """
        Predict the states from time 0 through k-1 in the absence of observations.

        Parameters
        ----------
        x : ndarray of shape (n,)
            The state estimate at time k.
        k : integer
            The current time step.

        Returns
        -------
        out : ndarray of shape (n,k)
            The predicted states from time 0 up through k-1 (in that order).
        """
        # initialize necessary values ##########################################
        n = len(x)
        out = np.zeros((n, k))
        out[:, -1] = x

        # predict previous k states ############################################
        for i in range(1, k):
            out[:, -1 - i] = inv(self.F_)@(out[:, -i] - self.u_)

        return out[:, :-1]


def problem2():
    """
    Instantiate and retrun a KalmanFilter object with the transition and observation
    models F and H, along with the control vector u, corresponding to the
    projectile. Assume that the noise covariances are given by
    Q = 0.1 · I4
    R = 5000 · I2.

    Return the KalmanFilter Object
    """
    # initialize values necessary to return desired filter object ##############
    u = np.array([0., 0., 0., -0.98])
    Q = 0.1*np.eye(4)
    R = 5000.*np.eye(2)
    F = np.array([[1., 0., 0.1, 0.],
                  [0., 1., 0., 0.1],
                  [0., 0., 1., 0.],
                  [0., 0., 0., 1.]])
    H = np.array([[1., 0., 0., 0.],
                  [0., 1., 0., 0.]])

    return KalmanFilter(F,Q,H,R,u)


def problem5():
    """
    Calculate an initial state estimate xb200. Using the initial state estimate,
    P200 and your Kalman Filter, compute the next 600 state estimates.
    Plot these state estimates as a smooth green
    curve together with the radar observations (as red dots) and the entire
    true state sequence (as blue curve).
    """
    # initialize necessary objects and values ##################################
    filter = problem2()
    states, obs = filter.evolve(np.array([0, 0, 300, 600]), 1250)
    s_x = obs[0, 200]
    s_y = obs[1, 200]

    # find average of velocities ###############################################
    P0 = 10e6*filter.Q_
    diff = np.diff(obs[:, 200:210])
    V_x = np.mean(diff[0, :])/0.1
    V_y = np.mean(diff[1, :])/0.1
    x0 = np.array([s_x, s_y, V_x, V_y])
    out = filter.estimate(x0, P0, obs[:, 200:801])

    # plot results #############################################################
    fig,ax = plt.subplots(1, 2)
    ax[0].plot(states[0, :], states[1, :], color='blue', label='Actual')
    ax[0].plot(out[0, :], out[1, :], color='green', label='Estimate')
    ax[0].scatter(obs[0, 200:801], obs[1, 200:801], s=1, c='r', label='Radar')
    ax[0].set_title("State Estimates, Observations v. True State Sequence")

    ax[1].plot(states[0, :], states[1, :], color='blue', label='Actual')
    ax[1].plot(out[0, :], out[1, :], color='green', label='Estimate')
    ax[1].scatter(obs[0, 200:801], obs[1, 200:801], s=1, c='r', label='Radar')
    ax[1].set_xlim([7300, 9300])
    ax[1].set_ylim([11700, 13700])
    ax[1].set_title("State Estimates, Observations, TSS Zoomed In")
    plt.legend()
    plt.show()


def problem7():
    """
    Using the final state estimate xb800 that you obtained in Problem 5,
    predict the future states of the projectile until it hits the ground.
    Plot the actual state sequence together with the predicted state sequence
    (as a yellow curve), and observe how near the prediction is to the actual
    point of impact. Y
    """
    # initialize necessary objects and values ##################################
    filter = problem2()
    states, obs = filter.evolve(np.array([0, 0, 300, 600]), 1250)
    s_x = obs[0, 200]
    s_y = obs[1, 200]

    # find average of velocities ###############################################
    P0 = 10e6*filter.Q_
    diff = np.diff(obs[:, 200:210])
    V_x = np.mean(diff[0, :])/0.1
    V_y = np.mean(diff[1, :])/0.1
    x0 = np.array([s_x, s_y, V_x, V_y])
    temp_out = filter.estimate(x0, P0, obs[:, 200:801])

    # create predictions #######################################################
    x0 = temp_out[:, -1]
    out = filter.predict(x0, 450)
    s_i = np.argmin(np.absolute(states[1, 800:]))
    o_i = np.argmin(np.absolute(out[1, :]))
    if s_i<o_i:
        low = states[0, s_i + 800] - 100
        high = out[0, o_i] + 100
    else:
        low = out[0, o_i] - 100
        high = states[0, s_i + 800] + 100

    # plot results #############################################################
    fig,ax = plt.subplots(1, 2)
    ax[0].plot(states[0, :], states[1, :], color='blue', label='Actual')
    ax[0].plot(out[0, :], out[1, :], color='yellow', label='Predicted')
    ax[0].set_title("Prob 7")

    ax[1].plot(states[0, :], states[1, :], color='blue', label='Actual')
    ax[1].plot(out[0, :], out[1, :], color='yellow', label='Predicted')
    ax[1].set_xlim(low, high)
    ax[1].set_ylim([0, 100])
    ax[1].set_title("Prob 7 Zoomed In")
    plt.legend()
    plt.show()


def problem9():
    """
     Using your state estimate xb250, predict the point of origin of the
     projectile along with all states leading up to time step 250.
     Plot these predicted states (in cyan) together with the original state
     sequence. Repeat the prediction starting with xb600.
     """
    # initialize necessary objects and values ##################################
    filter = problem2()
    states, obs = filter.evolve(np.array([0, 0, 300, 600]), 1250)
    s_x = obs[0, 200]
    s_y = obs[1, 200]

    # find average of velocities ###############################################
    P0 = 10e6*filter.Q_
    diff = np.diff(obs[:, 200:210])
    V_x = np.mean(diff[0, :])/0.1
    V_y = np.mean(diff[1, :])/0.1
    x0 = np.array([s_x, s_y, V_x, V_y])
    temp_out = filter.estimate(x0, P0, obs[:, 200:801])

    # create predictions #######################################################
        # using the 250th state ################################################
    x0 = temp_out[:, 49] 
    out = filter.rewind(x0, 300)
    o_i = np.argmin(np.absolute(out[1, :]))
    if 0<out[0, o_i]: 
        low_1 = -100
        high_1 = out[0, o_i] + 100
    else:
        low_1 = out[0, o_i] - 100
        high_1 = 100

        # using the 600th state ################################################
    x0 = temp_out[:, 399] 
    temp_out_2 = filter.rewind(x0, 700)
    o_i = np.argmin(np.absolute(temp_out_2[1, :]))
    if 0<temp_out_2[0, o_i]: 
        low_2 = -100
        high_2 = temp_out_2[0, o_i] + 100
    else:
        low_2 = temp_out_2[0, o_i] - 100
        high_2 = 100

    # plot results #############################################################
    fig,ax = plt.subplots(2, 2)
    ax[0, 0].plot(states[0, :], states[1, :], color='blue', label='Actual')
    ax[0, 0].plot(out[0, :], out[1, :], color='cyan', label='Predicted')
    ax[0, 0].set_title("Prob 9: 250th State")

    ax[0, 1].plot(states[0, :], states[1, :], color='blue', label='Actual')
    ax[0, 1].plot(out[0, :], out[1, :], color='cyan', label='Predicted')
    ax[0, 1].set_xlim(low_1, high_1)
    ax[0, 1].set_ylim([0, 100])
    ax[0, 1].set_title("Prob 9: 250th State Zoomed In")

    ax[1, 0].plot(states[0, :], states[1, :], color='blue', label='Actual')
    ax[1, 0].plot(temp_out_2[0, :], temp_out_2[1, :], color='cyan', label='Predicted')
    ax[1, 0].set_title("Prob 9: 600th State")

    ax[1, 1].plot(states[0, :], states[1, :], color='blue', label='Actual')
    ax[1, 1].plot(temp_out_2[0, :], temp_out_2[1, :], color='cyan', label='Predicted')
    ax[1, 1].set_xlim(low_2, high_2)
    ax[1, 1].set_ylim([0, 100])
    ax[1, 1].set_title("Prob 9: 600th State Zoomed In")
    plt.legend()
    plt.tight_layout()
    plt.show()

# test code ####################################################################
# if __name__ == "__main__":
#     problem5()
#     problem7()
#     problem9()